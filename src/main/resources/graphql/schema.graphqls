# This is just a sample schema.

type User {
    username: String
    email: String
}

type Query {
    user(username: String!, password: String!): User!
    expense(id: Int!): CreateExpensePayload!
}

type Mutation {
    createUser(username: String!, password: String!, email: String!): CreateUserPayload!
    deleteUser(username: String!, password: String!): DeleteUserPayload!
    createExpense(title: String!, description: String!, amount: Float!): CreateExpensePayload!
}

## Using union types are a best practice because they allow you to send separate success and failure payloads and
## because adding fields to either payload will always be backwards compatible.
##
## Consuming union types from the client-side will look something like this:
##
## mutation {
##   createUser(username: "hark", password: "pwd", email: "hsk@gmail.com") {
##     ...on CreateUserSuccess {
##       user {
##         username
##         email
##       }
##     }
##
##     ...on CreateUserFailed {
##       exceptionName
##       errorMessage
##     }
##   }
## }

union CreateUserPayload = CreateUserSuccess | CreateUserFailed

type CreateUserSuccess {
    user: User!
}

type CreateUserFailed {
    exceptionName: String
    errorMessage: String
}

union DeleteUserPayload = DeleteUserSuccess | DeleteUserFailed

type DeleteUserSuccess {
    user: User!
}

type DeleteUserFailed {
    exceptionName: String
    errorMessage: String
}




## 
## EXPENSE RELATED
##

type Expense {
	amount: Float
	title: String
	description: String	
}

union CreateExpensePayload = CreateExpenseSuccess | CreateExpenseFailed 

type CreateExpenseSuccess {
    expense: Expense!
}

type CreateExpenseFailed {
    exceptionName: String
    errorMessage: String
}


